#LyX 1.6.2 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
 \usepackage{parskip}
\setlength{\parindent}{0pt}
\lhead{Specifications for the Spark File-transfer Tool}
\chead{}
\rhead{Version 0.1}
\lfoot{Pierre-André Saulais <pasaulais@free.fr>}
\cfoot{}
\rfoot{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\end_preamble
\use_default_options false
\language english
\inputencoding auto
\font_roman charter
\font_sans helvet
\font_typewriter beramono
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Specifications for the Spark File-transfer Tool (version 0.1)
\end_layout

\begin_layout Author
Pierre-André Saulais <pasaulais@free.fr>
\end_layout

\begin_layout Date
Last updated --- August 21, 2009
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section*
Project summary and goals
\end_layout

\begin_layout Standard
Spark is a tool for transfering files over the Internet.
 It is meant to be robust and easy to use, as well as replacing IM software
 for sending files.
 Indeed IM file-transfer protocols are usually lacking in robustness (interrupte
d transfers can't be resumed) and sometimes in privacy and speed (files
 might be forwarded by an IM server).
 
\end_layout

\begin_layout Standard
Spark is 
\emph on
synchronous
\emph default
, which means both parties have to agree to use it at the same time before
 sending files.
 It requires some additional communication, typically exchanging IP addresses.
 That's why it's meant to be used along with IM software and only as a replaceme
nt for the file-transfer part.
 There is no chat features built-in and no plan to implement such features
 in the future.
\end_layout

\begin_layout Standard
IM software isn't the only way to send file over the Internet, but other
 tools have their share of constraints.
 Most file-transfer protocols (like FTP or SCP/SFTP) require a permanent
 server to be set up and configured before you can start using them.
 Most networking file systems (like NFS or SMB) haven't been designed with
 security or the Internet in mind.
 Email can be used to transfer files, but typically mailboxes have either
 a per-file size cap or a global size quota.
 That's why sending files by email is only practical for small files.
\end_layout

\begin_layout Section
Functional specifications
\end_layout

\begin_layout Subsection
Users and peers
\end_layout

\begin_layout Standard
Spark is intended to be used by pairs of users.
 The person using Spark on the machine of interest is called the 
\emph on
user
\emph default
.
 Any person remotely connected to the user through the network is called
 the 
\emph on
peer
\emph default
.
 Of course this is arbitrary: the peer is also an user and can have a peer.
\end_layout

\begin_layout Subsection
The shared file lists
\end_layout

\begin_layout Standard
From the user point of view, Spark can be used to manipulate a list of 
\emph on
shared files
\emph default
.
 Each file is either 
\emph on
local
\emph default
 (originated from the user's machine) or 
\emph on
remote
\emph default
 (originated from the peer's machine).
 Each file also has a 
\emph on
transfer state
\emph default
; this indicates how much of the file has been sent or received, but also
 when it started, when it is estimated to be finished, the download or upload
 speed, etc.
\end_layout

\begin_layout Standard
Despite the name, each user has their own shared file list.
 The files are shared between users, not the lists.
 Most actions affect both lists in the same way, but the two can differ.
\end_layout

\begin_layout Subsubsection
Adding files
\end_layout

\begin_layout Standard
The user can add (local) files from their machine to the list, whether they
 are connected to a peer or not.
 Peers can see the user's shared files and receive them only when the two
 are connected.
\end_layout

\begin_layout Subsubsection
Removing files
\end_layout

\begin_layout Standard
The user can remove local files from the list.
 The files are removed from the peer's list, but only if they have never
 been transfered at all.
 In any case, they aren't deleted from the user's disk.
\end_layout

\begin_layout Standard
The user can also remove remote files from the list.
 This causes the files to be hidden from the user, but doesn't remove them
 from the peer's shared list.
 Nor does it delete them from the peer's computer
\end_layout

\begin_layout Standard
A warning dialog is shown when the user tries to remove a file which is
 being transfered.
 This dialog asks the user to confirm they really want to cancel the transfer.
 It also gives the option to remove any partially received file (associated
 to the transfer) from the user's disk.
\end_layout

\begin_layout Subsubsection
Persistence
\end_layout

\begin_layout Standard
This file list is expected to be persistent, ie.
 closing Spark and launching it again shows the same list.
 The main purpose of this feature is to enable resuming transfers no matter
 what happens to Spark (eg.
 connection loss, OS crash or reboot while Spark is running in the background,
 bug/freeze in Spark).
 Another reason for the list to be persistent is to easily let the user
 open a received file without having to know where the file actually is
 on the disk.
\end_layout

\begin_layout Subsection
Connection
\end_layout

\begin_layout Standard
Most of Spark's features are only usable when the user is connected to a
 peer.
 To do so they have to know the IP address (or DNS name) and port used by
 the peer.
 This information is expected to be communicated through another mean (eg.
 IM).
 It doesn't matter which user initiates the connection as it goes both ways.
\end_layout

\begin_layout Subsection
Transfers
\end_layout

\begin_layout Section
Technical specifications
\end_layout

\begin_layout Subsection
Language and dependencies
\end_layout

\begin_layout Standard
Spark is written in Python 2.6 and uses Qt 4
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Exact version to be determined
\end_layout

\end_inset

 through PyQt4 for the GUI.
 SQLite is used for data persistence.
 The reason behind these choices is to be able to quickly develop a multi-platfo
rm GUI application with a language that is simple, flexible and fun to use.
 In the future, extension modules might be written in C to improve the performan
ce of critical parts of the application.
\end_layout

\begin_layout Subsection
Common concepts
\end_layout

\begin_layout Subsubsection
Blocks
\end_layout

\begin_layout Standard
One major feature is the ability to resume a transfer that's been aborted
 for whatever reason.
 This feature is implemented by dividing a file into chunks (called 
\emph on
blocks
\emph default
) and keeping track of which blocks have been successfully received.
 That way, resuming an aborted transfer is only a matter of figuring out
 which blocks are missing and sending them.
\end_layout

\begin_layout Subsubsection
Transfers
\end_layout

\begin_layout Standard
A transfer is the operation of sending blocks from the server to the client.
 Transfers have a state (eg.
 active, paused, finished, failed, etc) and notifications are sent whenever
 it changes.
 Transfers also have an identifier, which means a server can have many transfers
 active at the same time.
 Every block sent in the context of a transfer comes from the same file,
 but the client is free to specify which blocks are to be sent.
 Typically the client asks for every missing block of a given file, which
 is the whole file if it is the first transfer.
\end_layout

\begin_layout Subsection
Network architecture
\end_layout

\begin_layout Subsubsection
Client and server
\end_layout

\begin_layout Standard
From an implementation point of view there is a clear separation between
 sending and receiving files.
 The part in charge of sending files is called the 
\emph on
server
\emph default
 while it is the 
\emph on
client's
\emph default
 responsability to receive them.
 As far as the user is concerned there is no separation.
 When two users are connected they can both send and receive files at the
 same time.
\end_layout

\begin_layout Subsubsection
Messages
\end_layout

\begin_layout Standard
The client and the server communicate through messages.
 A message could be a request, a response or a notification.
 Requests are usually sent by the client, and are answered by a response
 from the server.
 
\end_layout

\begin_layout Standard
A notification is a message that says something has happened.
 For example, the client periodically sends a message to notify the server
 of the number of blocks that have been received (valid or not).
\end_layout

\begin_layout Subsubsection
Channels
\end_layout

\begin_layout Standard
Different transport protocols can be used for transfering data (ie.
 messages and blocks) between the client and the server.
 While a raw TCP connection is the main (and first) transport implemented
 for Spark, blocks could be sent with UDP.
 Likewise authentication and privacy could be implemented by using a SSH
 library.
 
\end_layout

\begin_layout Standard
The idea behind channels is to abstract away the differences between transport
 protocols.
 That way 
\begin_inset Quotes eld
\end_inset

TCP
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

UDP
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

SSH
\begin_inset Quotes erd
\end_inset

 would be three kinds of channels which could be used interchangeably for
 transfering data.
 It would also be fairly easy to implement another kind of channel without
 modifying the file-transfer logic.
\end_layout

\begin_layout Subsection
Process and thread architecture
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ProcessArch.eps
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Overview of the process architecture
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "Flo:ProcessArch"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In my opinion using separate processes or threads is a given when writing
 graphical tools that use sockets (eg.
 network-aware applications).
 Indeed networking code has no place in the GUI thread, and the 
\begin_inset Quotes eld
\end_inset

blocking until a message is received from the socket
\begin_inset Quotes erd
\end_inset

 approach fits separate threads/processes very well.
 
\end_layout

\begin_layout Standard
Spark needs to run a GUI, a server and a client.
 These different parts are only very loosely related, it makes sense to
 separate them thread- or process-wise.
 Since the client and server parts share no state (besides maybe the persistent
 data store), each will run in a separate process.
 This doesn't prevent them to share code though.
 
\end_layout

\begin_layout Standard
This approach (shown in figure 
\begin_inset CommandInset ref
LatexCommand vref
reference "Flo:ProcessArch"

\end_inset

) does make the communication betweens parts more complicated (ie.
 it requires an inter-process communication mechanism, rather than just
 function calls with share state).
 On the upside, the interface between them has to be clearly defined and
 is easier to understand than if a single process approach was used.
 This architecture is also in my opinion more flexible and robust.
 In particular, the client and server can each be used as a stand-alone
 command-line application, without using the GUI at all.
 This makes testing simpler and more easily automated.
\end_layout

\begin_layout Subsection
GUI-FileShare interface
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename View.eps
	lyxscale 50
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Overview of the GUI-FileShare interface
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "Flo:GUI_FileShare_Interface"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since the GUI and FileShare (Client/Server) parts are running on different
 processes, the method they use for communicating should be clearly defined
 (see the class diagram in figure 
\begin_inset CommandInset ref
LatexCommand vref
reference "Flo:GUI_FileShare_Interface"

\end_inset

).
\end_layout

\begin_layout Standard
The simplest and most flexible approach I have found so far is serializing/deser
ializing objects with Python's 
\emph on
pickle
\emph default
 module on the process' standard input/output streams.
 For unfrequent events (file added, removed, state changed), a notification
 is sent to stdout.
 For very frequent events (transfer progress changed), the GUI has to ask
 the file share process for the transfer's latest progress info (eg.
 
\begin_inset Quotes eld
\end_inset

poll
\begin_inset Quotes erd
\end_inset

 the file share process for progress info every 
\begin_inset Formula $x$
\end_inset

 ms).
\end_layout

\begin_layout Subsection
Network protocol
\end_layout

\begin_layout Standard
A protocol is needed to communicate between both peers' Spark processes.
 The proposed protocol is a simple text protocol based on JSON to encode
 more complex data.
 It isn't 100% text though, since blocks are sent as binary data.
 The reason behind a mostly-text protocol is to make it easy to read by
 humans.
 This makes debugging (e.g.
 with a packet sniffer) and interoperability easier.
\end_layout

\begin_layout Standard
This section assumes a stream-based transport protocol (e.g.
 TCP) is used.
 This is why all messages end with a newline.
 This protocol could be used with message-based protocols (e.g.
 UDP, SCTP) without newline delimiters.
\end_layout

\begin_layout Subsubsection
Protocol negociation
\end_layout

\begin_layout Standard
For now there is only one version of the protocol, but it is anticipated
 that there will be other, incompatible versions of the protocol in the
 future.
 This is why after a connection is initiated both peers have to agree on
 the protocol to use.
\end_layout

\begin_layout Standard
The peer initiating the connection first sends the list of every supported
 protocol (separated by spaces): 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}spark > SPARKv1 SPARKv2
\backslash
r
\backslash
n
\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The other peers replies with the name of the protocol it chose:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}spark < SPARKv1
\backslash
r
\backslash
n
\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this example the initiating peer supports the 
\begin_inset Quotes eld
\end_inset

SPARKv1
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

SPARKv2
\begin_inset Quotes erd
\end_inset

 protocols, but the other peer chose to use the 
\begin_inset Quotes eld
\end_inset

SPARKv1
\begin_inset Quotes erd
\end_inset

 protocol.
 Maybe it doesn't support the second version.
\end_layout

\begin_layout Subsubsection
General structure of a message
\end_layout

\begin_layout Paragraph*
Text messages
\end_layout

\begin_layout Standard
In the current version of the protocol, there are three kinds of text messages:
 requests, responses and notifications.
 Each message contains several elements:
\end_layout

\begin_layout Itemize
a type, represented by a string (starting with a non-digit character, eg.
 
\begin_inset Quotes eld
\end_inset

start-transfer
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
a kind, represented by one character:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

>
\begin_inset Quotes erd
\end_inset

 for requests
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

<
\begin_inset Quotes erd
\end_inset

 for responses
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

!
\begin_inset Quotes erd
\end_inset

 for notifications
\end_layout

\end_deeper
\begin_layout Itemize
an integer identifier.
 This is mainly used for matching responses with requests
\end_layout

\begin_layout Itemize
optional data, which is formatted in JSON
\end_layout

\begin_layout Itemize
a newline (either 
\begin_inset Quotes eld
\end_inset


\backslash
r
\backslash
n
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\backslash
n
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
Elements are separated with spaces.
 As an exception no space is needed before the trailing newline.
 The following is an example of a text message: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}start-transfer > 27 {'id' : 1}
\backslash
r
\backslash
n
\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Binary messages
\end_layout

\begin_layout Standard
In the current version of the protocol, binary messages are only used to
 send blocks.
 The syntax for such messages is very simple.
 Before the binary data is added a text prefix indicating its size.
 This prefix consists of the text 
\begin_inset Quotes eld
\end_inset

0x
\begin_inset Quotes erd
\end_inset

 followed by six hexadecimal digits.
 A newline follows the binary data.
\end_layout

\begin_layout Standard
The following is an example of a binary message: (
\begin_inset Quotes eld
\end_inset

<
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

>
\begin_inset Quotes erd
\end_inset

 denote binary data)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}0x000408<0x0001><0x0001><0x00000000><0x0400><block data>
\backslash
r
\backslash
n
\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example of an exchange between two peers
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}Peer A initiates the connection.
\end_layout

\begin_layout Plain Layout

Peer B accepts the connection.
\end_layout

\begin_layout Plain Layout

A: spark > SPARKv1
\backslash
r
\backslash
n
\end_layout

\begin_layout Plain Layout

B: spark < SPARKv1
\backslash
r
\backslash
n
\end_layout

\begin_layout Plain Layout

A: list-files > 0 {'register' : true}
\backslash
r
\backslash
n
\end_layout

\begin_layout Plain Layout

B: list-files < 0 {'<guid>' : {'id' : '<guid>', 'name' : 'Report.pdf', 
\end_layout

\begin_layout Plain Layout

    'size' : 3145728, 'last-modified' : '20090619T173529.000Z'}}
\backslash
r
\backslash
n
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

B: file-added ! 55 {'id' : '<guid>', 'name' : 'SeisRoX-2.0.9660.exe',
\end_layout

\begin_layout Plain Layout

    'size' : 3145728, 'last-modified' : '20090619T173529.000Z'}
\backslash
r
\backslash
n
\end_layout

\begin_layout Plain Layout

A: create-transfer > 26 {'blocksize' : 1024, 'ranges' : 
\end_layout

\begin_layout Plain Layout

    [{'start' : 0, 'end' : 3071}]}
\backslash
r
\backslash
n
\end_layout

\begin_layout Plain Layout

B: create-transfer < 26 {'id' : 1, 'state' : 'unstarted'}
\backslash
r
\backslash
n
\end_layout

\begin_layout Plain Layout

A: start-transfer > 27 {'id' : 1}
\backslash
r
\backslash
n
\end_layout

\begin_layout Plain Layout

B: start-transfer < 27 {'id' : 1, 'state' : 'starting'}
\backslash
r
\backslash
n
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

B: transfer-state ! 56 {'id' : 1, 'state' : 'active'}
\backslash
r
\backslash
n
\end_layout

\begin_layout Plain Layout

B: 0x000408<0x0001><0x0001><0x00000000><0x0400><raw block data>
\backslash
r
\backslash
n
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

B: 0x000408<0x0001><0x0001><0x00000BFF><0x0400><raw block data>
\backslash
r
\backslash
n
\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
List of requests and responses
\end_layout

\begin_layout Subsubsection
List of notifications
\end_layout

\end_body
\end_document
